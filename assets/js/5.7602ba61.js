(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{194:function(e,t,a){e.exports=a.p+"assets/img/helios-rx.3264e953.png"},195:function(e,t,a){e.exports=a.p+"assets/img/overview.e5bb1cc1.png"},231:function(e,t,a){"use strict";a.r(t);var s=a(0),i=Object(s.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"introduction"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#introduction"}},[e._v("#")]),e._v(" Introduction")]),e._v(" "),s("h2",{attrs:{id:"what-is-heliosrx"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#what-is-heliosrx"}},[e._v("#")]),e._v(" What is heliosRX?")]),e._v(" "),s("p",[s("strong",[e._v("heliosRX")]),e._v(" is a front-end ORM (Object-Relational Mapping) layer\nfor reactive real-time web applications using Firebase Realtime Database.\nheliosRX allows developers to define "),s("code",[e._v("models")]),e._v(" based on schema files.")]),e._v(" "),s("p",[e._v("While using the Firebase Client API is fine for smaller applications, enforcing\nsome structure is almost necessary to successfully manage more complex applications.\nEnsuring some structure simplifies life a lot and gives you the best of both\nthe NoSQL and the SQL world.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(194),alt:"heliosRX"}})]),e._v(" "),s("p",[e._v("heliosRX consists of two parts: A generator that can generate security rules\nfrom schema files, thus creating a data model for the server, and a javascript\nORM library, that creates a nice abstraction to Realtime Database based on the\nexact same data model. The basic idea here is: "),s("strong",[e._v("Describe a model once, reuse\nit as much as possible")]),e._v(". Another goal of heliosRX is therefor to target\ndifferent platforms with a shared codebase and provide a unified API to\nthe database for different platforms, such as:")]),e._v(" "),s("ul",[s("li",[e._v("Babel for Web / Desktop")]),e._v(" "),s("li",[e._v("Dart / Flutter for Mobile")]),e._v(" "),s("li",[e._v("Node for admin tools and cloud functions")])]),e._v(" "),s("p",[e._v("While currently heliosRX is build for Vue and Firebase Realtime Database,\nother backend integrations might get implemented in the future (e.g. GraphQL).")]),e._v(" "),s("h2",{attrs:{id:"when-should-i-use-heliosrx"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#when-should-i-use-heliosrx"}},[e._v("#")]),e._v(" When should I use heliosRX?")]),e._v(" "),s("p",[e._v("If your using Firebase as your backend and if you're building a SPA that\nis a little bit more complex then a simple to-do list, then heliosRX is\nprobably very useful for you. Some benefits of using heliosRX over\njust Firebase Client API are:")]),e._v(" "),s("ul",[s("li",[e._v("➡️ Easy, straight forward API based on model definitions/schemata")]),e._v(" "),s("li",[e._v("➡️ Define schemas and locations for your data")]),e._v(" "),s("li",[e._v("➡️ Consistent data validation on client and server")]),e._v(" "),s("li",[e._v("➡️ Automatically generate Security Rules based on schemata")]),e._v(" "),s("li",[e._v("➡️ Allows easy sorting of objects")]),e._v(" "),s("li",[e._v("➡️ Automatic type conversion for timestamps to moment-js")]),e._v(" "),s("li",[e._v("➡️ Additional layer of abstraction and therefore less vendor lock-in")]),e._v(" "),s("li",[e._v("➡️ State management, no "),s("code",[e._v("Vuex")]),e._v(" needed (although heliosRX uses Vuex internally)")]),e._v(" "),s("li",[e._v("➡️ Write significantly less code")])]),e._v(" "),s("p",[e._v("If that makes sense to you, you should give heliosRX a try.")]),e._v(" "),s("h2",{attrs:{id:"how-it-works"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#how-it-works"}},[e._v("#")]),e._v(" How it works")]),e._v(" "),s("p",[e._v("To understand how heliosRX works, have a look following picture. Basically the\ndatabase is specified by (1) model definition files, that describe "),s("em",[e._v("which")]),e._v(" fields\ncan be stored and (2) a path definition file, that describes "),s("em",[e._v("where")]),e._v(" data is\nstored.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(195),alt:"heliosRX"}})]),e._v(" "),s("p",[e._v("heliosRX uses the bolt language and the "),s("a",{attrs:{href:"https://github.com/FirebaseExtended/bolt",target:"_blank",rel:"noopener noreferrer"}},[e._v("bolt compiler"),s("OutboundLink")],1),e._v(". The model definitions can then be used to create a\nbolt files, which are merged and then compiled to Firebase security rules.")]),e._v(" "),s("p",[e._v("Also an API is generated that can be used to access the database in a straight\nforward way. Based on the model definition, model instances can be created from\nexisting or new data. Under the hood heliosRX creates a new "),s("code",[e._v("Vue")]),e._v(" instance within\neach model instance, that manages state and reactivity, obviating the need\nfor other state management solutions, like "),s("code",[e._v("Vuex")]),e._v(".")])])}),[],!1,null,null,null);t.default=i.exports}}]);